# Theory 1

## Scale Factors
	1. Prec - have we done this before?
		We should choose experienced developers rather than novices. Doing so will decrease the effort needed.
	2. Flex - development flexibility
		If we have to meet lots of interface specifications then that will drasticaly harm our speed. Let's minimize those specifications.
	3. Resl - risk resolution
		We should identify as many risks as possible and develop a plan to mitigate each one.
	4. Team - how 'together' the team is
		We'll choose the team that has worked together a lot rather than forming a brand new team. Doing so will decrease our effort.
	5. Pmat - process maturity
		Switching from our ad-hoc and undocumented process to a proven process like waterfall or agile lets us draw from past experiences and will help us complete our project.

## Decrease effort
	1. acap - analyst capability
		Our best business analyst left and now our team is having a harder time identifying requirements.
	2. pcap - programmer capability
		We found out that one programmer always slacked off. We could replace him with another programmer to get more work done.
	3. pcon - programmer continuity
		We work hard to keep our team happy so that they don't leave. If they did, we'd have to keep training new people and would lose time.
	4. aexp - analyst experience
		We should use our most experieneced team of analysts for the most complex portions of the system.
	5. pexp - programmer experience
		We should use our most experieneced team of programmers for the most complex portions of the system.
	6. ltex - language and tool experience
		Most of our team knows Java. No one knows Haskell. Therefore, we are choosing to use Java so we can ship this faster.
	7. tool - use of tools
		We could buy better development tools for everyone to decrease our time to market.
	8. site - how many physical locations and how well connected?
		We could bring all employees onsite to improve communication and reduce effort.
	9. sced - length of schedule
		We have a compressed schedule and thus will have to put more work in near the end of the project.

## Increase effort
	1. rely - how reliable the software must be
		NASA needs our software to never crash. This is going to take a ton more effort than we thought...
	2. data - secondary memory storage requirements
		Sounds like we'll have to store multiple petabytes of information which will require a lot of overhead.
	3. cplx - program complexity
		When the client called us initially, the project sounded simple, but we found out it was very complex once we talked with him.
	4. ruse - software reuse
		We want to reuse this software later so we'll have to put more time into it now so that we don't have to later.
	5. docu - documentation requirements
		We're going to have to ship our portion of the contract to have another team finish it. This means we to need to heavily document the work which will take more time.
	6. time - runtime pressure
		We're making a video game, thus everything needs to run in real time. This will take a lot more work.
	7. stor - main memory requirements
		If we have to run on embedded systems, we won't have very much memory and will have to design our system so that it can run in those constraints.
	8. pvol - platform volatility
		If we use a long term support release of Ubuntu we should have to worry about less frequent updates.

